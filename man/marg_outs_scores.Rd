% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/marg_outs_scores.R
\name{marg_outs_scores}
\alias{marg_outs_scores}
\title{Detection of marginal outliers with given scores of outlyingness.}
\usage{
marg_outs_scores(
  data,
  disc_cols,
  outscorediscdf,
  outscorecontdf,
  outscorediscdfcells,
  alpha = 0.01,
  rho = 0.2,
  epsilon = 0.02
)
}
\arguments{
\item{data}{Data frame of mixed-type data. Should be of class 'data.frame'.}

\item{disc_cols}{Column indices of discrete variables.}

\item{outscorediscdf}{Data frame with discrete scores of outlyingness.
Should be of dimension (nrow(data) x 2) and of class 'data.frame'. First column should
include the row/observation number and second column should include the
discrete scores of outlyingness.}

\item{outscorecontdf}{Data frame with continuous scores of outlyingness.
Should be of dimension (nrow(data) x 2) and of class 'data.frame'.
First column should include the row/observation number and second column should include
the continuous scores of outlyingness.}

\item{outscorediscdfcells}{Matrix of contributions of discrete variables to the discrete scores of
outlyingness. Should be of dimension (nrow(data) x length(disc_cols)) and of class 'data.frame'.}

\item{alpha}{Significance level for the simultaneous Multinomial confidence intervals constructed for calculating discrete scores,
determining what the frequency thresholds should be for itemsets of different length. Must be a positive real,
at most equal to 0.20. A greater value leads to a much more conservative algorithm that also penalises less
infrequent itemsets. Default value is 0.01.}

\item{rho}{Maximum proportion of outliers believed to be in the data set. Used together with epsilon
to determine a stopping criterion for the search for marginal outliers based on scores of outlyingness.
Must be a real number in range (0, 0.5) with rho + epsilon \eqn{\leq 0.50} (\eqn{\rho + \epsilon \leq 0.5}). A smaller rho assumes less outliers.
Defaults to 0.20 (20\%).}

\item{epsilon}{Additional proportion of outliers that we are willing to tolerate. Must be a number
in the range (0, 0.25) with rho + epsilon \eqn{\leq 0.50} (\eqn{\rho + \epsilon \leq 0.5}). Must also be smaller than rho, as it only represents
the additional error. Defaults to 0.02 (2\%).}
}
\value{
A list with 3 vectors; the vector "Discrete" includes the row indices
for the observations which are marginally outlying in the discrete space only (single
marginal outliers). The vector "Continuous" includes the row
indices for the observations which are marginally outlying in the continuous space only (only
single marginal outliers included). The vector "Combined" includes the row indices for
the combined marginal observations.
}
\description{
Function used to detect marginal outliers given scores of outlyingness. The function requires
the discrete and continuous scores provided to be data frames with 2 columns, the first column
being the observation number/index and the second column including the scores of outlyingness.
The matrix of contributions of the discrete variables to the discrete scores of outlyingness also
needs to be provided. This function can be used if the user wishes to use a different method for
calculating the scores of outlyingness for either the discrete or the continuous features.
}
\examples{
\dontrun{
dt <- gen_marg_joint_data(n_obs = 1000,
                          n_disc = 5,
                          n_cont = 5,
                          n_lvls = 3,
                          p_outs = 0.05,
                          jp_outs = 0.2,
                          assoc_target = c(1, 2),
                          assoc_vars = list(c(1, 2), c(4,5)),
                          assoc_type = c('linear', 'product'),
                          seed_num = 1)
discrete_scores <- disc_scores(data = dt, disc_cols = c(1:5))
continuous_scores <- cont_scores(data = dt, cont_cols = c(6:10))
marg_outs_scores(data = dt,
                 disc_cols = c(1:5),
                 outscorediscdf = discrete_scores[[2]],
                 outscorecontdf = continuous_scores,
                 outscorediscdfcells = discrete_scores[[3]],
                 alpha = 0.01,
                 rho = 0.20,
                 epsilon = 0.02)
}
}
